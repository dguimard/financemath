package com.guimard.finance.product;import com.guimard.finance.math.FinMath;import com.guimard.finance.math.Random;import com.guimard.finance.math.SFSMarkovChainImpl;public class ConstantVolatilityAsset extends Asset {    int pathCounter;    int branchCounter;    double r;    double mu;    double sigma;    double riskNeutralDriftDelta;    double marketDriftDelta;    double sigmaSqrtdt;    public ConstantVolatilityAsset            (int T, double dt, int nSignChange,             double S_0, double r, double q, double mu, double sigma) {        super(T, dt, S_0, q, nSignChange);        this.r = r;        this.mu = mu;        this.sigma = sigma;        volatilityIsDeterministic = true;        pathCounter = 0;        riskNeutralDriftDelta = -(q + 0.5 * sigma * sigma) * dt;        marketDriftDelta = (mu - r - 0.5 * sigma * sigma) * dt;        sigmaSqrtdt = sigma * Math.sqrt(dt);        // compute the nonstochastic riskfree bond        for (int t = 0; t <= T; t++) B[t] = Math.exp(r * t * dt);    } //end constructor    public double get_r() {        return r;    }    public double get_mu() {        return mu;    }    /**     * Constant asset price volatility.     */    public double get_sigma() {        return sigma;    }    public double get_sigmaSqrtdt(int t) {        return sigmaSqrtdt;    }    public void simulationInit(int t) {        if (t == 0) pathCounter = 0;    //it's  a full path simulation        else branchCounter = 0;      //it's a simulation of path branches    }    public double Sigma(int t) {        return sigma * Math.sqrt((T - t) * dt);    }    public void newWienerIncrements(int t) {        int m;        if (t == 0) m = pathCounter;  //it's a path simulation        else m = branchCounter;    //if t>0 it's a branch simulation        switch (m % nSignChange) {            case 0: //new standard normal increments                for (int u = t; u < T; u++) Z[u] = Random.STN();                break;            case 1: //increments driving the anthithetic path                for (int u = t; u < T; u++) Z[u] *= (-1);                break;            default: //change signs randomly                for (int u = t; u < T; u++) Z[u] *= Random.Sign();        }        if (t == 0) pathCounter++;        else branchCounter++;    } //end NewWienerIncrements    public void newPathBranch(int whichProbability, int t) {        double driftDelta = 0;        switch (whichProbability) {            case Flag.MARKET_PROBABILITY:                driftDelta = marketDriftDelta;                break;            case Flag.RISK_NEUTRAL_PROBABILITY:                driftDelta = riskNeutralDriftDelta;        }        //compute the driving standard normal increments        newWienerIncrements(t);        for (int u = t; u < T; u++) S[u + 1] = S[u] * Math.exp(driftDelta + sigmaSqrtdt * Z[u]);    } //end newPathBranch    public void timeStep(int whichProbability, int t) {        Z[t] = Random.STN();        //choose drift according to probability        double driftDelta = 0;        switch (whichProbability) {            case Flag.MARKET_PROBABILITY:                driftDelta = marketDriftDelta;                break;            case Flag.RISK_NEUTRAL_PROBABILITY:                driftDelta = riskNeutralDriftDelta;        }        S[t + 1] = S[t] * Math.exp(driftDelta + sigmaSqrtdt * Z[t]);    } //end timeStep    public void timeStep(int whichProbability, int t, int s) {        if (t == s) return;                   //do nothing        double driftDelta = 0;        switch (whichProbability) {            case Flag.MARKET_PROBABILITY:                driftDelta = marketDriftDelta;                break;            case Flag.RISK_NEUTRAL_PROBABILITY:                driftDelta = riskNeutralDriftDelta;        }        double drift = driftDelta * (s - t),                vol = sigmaSqrtdt * Math.sqrt(s - t);        S[s] = S[t] * Math.exp(drift + vol * Random.STN());    } //end timeStep    public int pathSegment(int whichProbability, int t, Trigger trg) {        int s = t;        do {            timeStep(whichProbability, s);            s++;        }        while ((s < T) && !trg.isTriggered(t, s));        return s;    } // end pathSegment    public void newPath(int whichProbability) {        for (int t = 0; t < T; t++) timeStep(whichProbability, t);    } //end newPath    private double f_plus(int i, int j) {        double sqrtdt = Math.sqrt(dt);        return (j - i + 0.5) / ((i + 0.5) * sigmaSqrtdt) + q * sqrtdt / sigma;    }    private double f_minus(int i, int j) {        double sqrtdt = Math.sqrt(dt);        return (j - i - 0.5) / ((i + 0.5) * sigmaSqrtdt) + q * sqrtdt / sigma;    }    // the largest j with N(f_plus(i,j))<=delta     private int j_min(int i, double delta) {        int j = 0, k = 10000, m;        while (FinMath.N(f_plus(i, k)) < delta) {            j = k;            k += 10000;        }        // now N(f_plus(i,k))>=\delta, N(f_minus(i,j))<\delta        while (k - j > 1) {            m = (j + k) / 2;            if (FinMath.N(f_plus(i, m)) > delta) k = m;            else j = m;        }        // now j is the largest k with N(f_plus(i,k)<=delta                    return j;    } // end j_min    // the smallest j with N(f_plus(i,j))>=1-delta     private int j_max(int i, double delta) {        int j = 0, k = 0, m;        while (FinMath.N(f_plus(i, j)) < 1 - delta) {            k = j;            j += 1000;        }        // now N(f_plus(i,j))>=1-\delta, N(f_minus(i,k))<=1-\delta        while (j - k > 1) {            m = (j + k) / 2;            if (FinMath.N(f_plus(i, m)) < 1 - delta) k = m;            else j = m;        }        // now j is the smallest j with N(f_plus(i,k)>=1-delta                   return j;    } // end j_max    /**     * a-array     */    private int[] a(int N, double delta) {        int[] a = new int[N];        for (int i = 0; i < N; i++) a[i] = j_min(i, delta);        return a;    }     private int[] b(int N, double delta) {        int[] b = new int[N];        for (int i = 0; i < N; i++) b[i] = Math.min(N - 1, j_max(i, delta));        return b;    }       private double[][] Q(int N, double delta) {        double[][] q = new double[N][];        for (int i = 0; i < N; i++) {            int ai = j_min(i, delta),                    bi = Math.min(N - 1, j_max(i, delta)),                    ni = bi - ai + 1;            q[i] = new double[ni];            if (ni == 1) q[i][0] = 1;            else                for (int j = 0; j < ni; j++) {                    if (j == 0) q[i][j] = FinMath.N(f_plus(i, j + ai));                    if ((0 < j) && (j < ni - 1))                        q[i][j] = FinMath.N(f_plus(i, j + ai)) - FinMath.N(f_minus(i, j + ai));                    if (j == ni - 1) q[i][j] = 1 - FinMath.N(f_minus(i, j + ai));                }        } // end for i        return q;    } // end Q    public SFSMarkovChainImpl markovChain(int N, double ds, final double delta) {        // initial state        int j_0 = (int) Math.round(S_0 / ds);        return new SFSMarkovChainImpl(T, j_0, N, a(N, delta), b(N, delta), Q(N, delta));    }}