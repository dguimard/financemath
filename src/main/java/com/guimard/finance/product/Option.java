package com.guimard.finance.product;import com.guimard.finance.math.ControlledRandomVariable;public abstract class Option {    String name;    boolean hasAnalyticPrice;    int T;    double dt;    double[] C;    Asset underlying;    double S_0;    double[] S;    double[] B;    public static final int            MARKET_PROBABILITY = Flag.MARKET_PROBABILITY,            RISK_NEUTRAL_PROBABILITY = Flag.RISK_NEUTRAL_PROBABILITY;    public static final int            MINIMUM_VARIANCE_DELTA = Flag.MV_DELTA,            ANALYTIC_MINIMUM_VARIANCE_DELTA = Flag.AM_DELTA,    MONTE_CARLO_DELTA = Flag.MC_DELTA,            ANALYTIC_DELTA = Flag.A_DELTA,    QUOTIENT_DELTA = Flag.Q_DELTA,            ANALYTIC_QUOTIENT_DELTA = Flag.AQ_DELTA;    double mu,          // drift of underlying            sigma,       // volatility of underlying            r,           // risk free rate            q;           // dividend yield of underlying    double a, b, alpha, beta, phi, psi;    public int get_T() {        return T;    }    public double get_dt() {        return dt;    }    public double[] get_C() {        return C;    }    public String getName() {        return name;    }    public Asset get_underlying() {        return underlying;    }    public boolean hasAnalyticPrice() {        return hasAnalyticPrice;    }    public boolean underlyingIsCVA() {        if (underlying instanceof ConstantVolatilityAsset)            return true;        else return false;    }    public boolean underlyingIsDividendFreeCVA() {        if ((underlyingIsCVA()) && (underlying.get_q() == 0))            return true;        else return false;    }    double kappa(int n) {        double lambda = mu - r - sigma * sigma / 2;        return n * (lambda + n * sigma * sigma / 2);    }    double F(double alpha, double beta) {        return (alpha / beta) * (Math.exp(beta * dt) - 1);    }    double F(int n) {        double qq = Math.exp((mu - r) * dt),     // "q" from DiscreteHedge.tex                sigmasqr = sigma * sigma,                k1 = kappa(1),                kn = kappa(n);        return qq * F(k1 + sigmasqr, kn + n * sigmasqr) - F(k1, kn);    }    double H(double alpha, double beta) {        return (alpha / beta) * ((beta * dt - 1) * Math.exp(beta * dt) + 1);    }    double H(int n) {        double qq = Math.exp((mu - r) * dt),     // "q" from DiscreteHedge.tex                sigmasqr = sigma * sigma,                k1 = kappa(1),                kn = kappa(n);        return qq * H(k1 + sigmasqr, kn + n * sigmasqr) - H(k1, kn);    }    public Option(Asset asset, String name) {        this.name = name;        underlying = asset;        hasAnalyticPrice = false;   //default        T = underlying.get_T();        dt = underlying.get_dt();        S_0 = asset.get_S_0();        C = new double[T + 1];        //recall T is the number of time steps to expiry        S = underlying.get_S();        B = underlying.get_B();        // if the underlying is a ConstantVolatilityAsset initialize drift,        // volatility,... and compute the hedge weight coefficients.        if (underlyingIsCVA()) {            ConstantVolatilityAsset cva = (ConstantVolatilityAsset) asset;            mu = cva.get_mu();            sigma = cva.get_sigma();            r = cva.get_r();            q = cva.get_q();            // constants to compute hedge weights            double qq, num, denom, sigmasqr,                    k1, k2, k3;            sigmasqr = sigma * sigma;            qq = Math.exp((mu - r) * dt);     // "q" from DiscreteHedge.tex            k1 = kappa(1);            k2 = kappa(2);            k3 = kappa(3);            a = Math.exp(sigmasqr * dt / 2);            b = a * a;            // phi, psi from DiscreteHedge.tex            num = sigmasqr * H(k1, k1) - F(k1, k3) + 2 * F(k1, k2) - F(k1, k1);            denom = sigmasqr * (qq - 1);            phi = num / denom;            num = 3 * F(k1, k2) - F(k1, k3) - 2 * F(k1, k1);            psi = num / (qq - 1);            // alpha, beta from DiscreteHedge.tex            denom = qq * qq * Math.exp(sigmasqr * dt) - 2 * qq + 1;            num = sigmasqr * H(1) - (F(3) - 2 * F(2) + F(1));            alpha = num / (sigmasqr * denom);            num = 3 * F(2) - F(3) - 2 * F(1);            beta = num / denom;        } // end if    }    public abstract double currentDiscountedPayoff();    public RandomVariable discountedPayoff() {        RandomVariable discounted_payoff = new RandomVariable() {            public double getValue(int t) {                underlying.newPathBranch(Flag.RISK_NEUTRAL_PROBABILITY, t);                return currentDiscountedPayoff();            }        }; // end discounted_payoff        return discounted_payoff;    } //end DiscountedPayoff    public ControlledRandomVariable controlledDiscountedPayoff() {        ControlledRandomVariable                controlled_discounted_payoff = new ControlledRandomVariable() {            public double[] getControlledValue(int t) {                double[] S = underlying.get_S();   //discounted price path                underlying.newPathBranch(Flag.RISK_NEUTRAL_PROBABILITY, t);                double x = currentDiscountedPayoff(),                        cv = S[T];                 // control variate                double[] value_control_variate_pair = {x, cv};                return value_control_variate_pair;            }            public double getControlVariateMean(int t) {                double[] S = underlying.get_S();                double q = underlying.get_q();                return S[t] * Math.exp(-q * (T - t) * dt);            }        }; // end controlled_discounted_payoff        return controlled_discounted_payoff;    } // end ControlledDiscountedPayoff    public double conditionalControlVariateCorrelation(int t, int nPaths) {        return                controlledDiscountedPayoff().correlationWithControlVariate(t, nPaths);    }    public double controlVariateCorrelation(int nPaths) {        return conditionalControlVariateCorrelation(0, nPaths);    }    public double discountedAnalyticPrice(int t) {        String message =                "Class Option: method discountedAnalyticPrice not implemented " +                        "in this generality. Aborting.";        //logit        return 0;    }    public double analyticDelta(int t) {        String message =                "Class Option: method analyticDelta not implemented " +                        "in this generality. Aborting.";        //logit        return 0;    }    public double analyticTheta(int t) {        String message =                "Class Option: method analyticTheta not implemented " +                        "in this generality. Aborting.";        //logit        return 0;    }    public double analyticVega(int t) {        String message =                "Class Option: method analyticVega not implemented " +                        "in this generality. Aborting.";        //logit        return 0;    }    public double analyticGamma(int t) {        String message =                "Class Option: method analyticGamma not implemented " +                        "in this generality. Aborting.";       //logit        return 0;    }    public double analyticSGamma(int t) {        String message =                "Class Option: method analyticSGamma not implemented " +                        "in this generality. Aborting.";        System.out.println(message);        System.exit(0);        return 0;    }    public double analyticThetaDelta(int t) {        String message =                "Class Option: method analyticThetaDelta not implemented " +                        "in this generality. Aborting.";        System.out.println(message);        System.exit(0);        return 0;    }    public double discountedMonteCarloPrice(int t, int nPath) {        underlying.simulationInit(t);        return discountedPayoff().conditionalExpectation(t, nPath);    }  //end discMonteCarloPrice    public double discountedMonteCarloPrice(int nPath) {        return discountedMonteCarloPrice(0, nPath);    }    public double discountedMonteCarloPrice            (int t, double precision, double confidence, int nSignChange) {        underlying.simulationInit(t);        return discountedPayoff().                conditionalExpectation(t, precision, confidence, nSignChange);    }    public double discountedMonteCarloPrice            (double precision, double confidence, int nSignChange) {        return discountedMonteCarloPrice(0, precision, confidence, nSignChange);    }    public double controlledDiscountedMonteCarloPrice(int t, int nPath) {        underlying.simulationInit(t);        return controlledDiscountedPayoff().conditionalExpectation(t, nPath);    }  //end controlledDiscountedMonteCarloPrice    public double controlledDiscountedMonteCarloPrice(int nPath) {        return controlledDiscountedMonteCarloPrice(0, nPath);    }    public double controlledDiscountedMonteCarloPrice            (int t, double precision, double confidence, int nSignChange) {        underlying.simulationInit(t);        return controlledDiscountedPayoff().                conditionalExpectation(t, precision, confidence, nSignChange);    }  //end discMonteCarloPrice    public double controlledDiscountedMonteCarloPrice            (double precision, double confidence, int nSignChange) {        return controlledDiscountedMonteCarloPrice                (0, precision, confidence, nSignChange);    }    public void newDiscountedPricePath(int whichProbability, int nPath) {        C[0] = discountedMonteCarloPrice(0, nPath);  //S[0] already initialized        for (int t = 0; t < T; t++) {            underlying.timeStep(whichProbability, t);            if (hasAnalyticPrice) C[t + 1] = discountedAnalyticPrice(t + 1);            else C[t + 1] = discountedMonteCarloPrice(t + 1, nPath);        }    }    public double minimumVarianceDelta(int whichProbability, int t, int nPath) {        underlying.simulationInit(t);         //sets pathCounter to zero        double numSum = 0, denomSum = 0;        if (hasAnalyticPrice()) {            // compute as E_t(DeltaS(t)DeltaC(t))/E_t(DeltaS(t)^2)            C[t] = discountedAnalyticPrice(t);            for (int n = 0; n < nPath; n++) {                double deltaSt, deltaCt;                underlying.timeStep(whichProbability, t);                deltaSt = S[t + 1] - S[t];                C[t + 1] = discountedAnalyticPrice(t + 1);                deltaCt = C[t + 1] - C[t];                numSum += deltaSt * deltaCt;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        } // end if        else if (whichProbability == RISK_NEUTRAL_PROBABILITY) {            // compute as E_t(DeltaS(t)h)/E_t(DeltaS(t)^2)            for (int n = 0; n < nPath; n++) {                double deltaSt, h;                underlying.timeStep(whichProbability, t);                deltaSt = S[t + 1] - S[t];                underlying.newPathBranch(whichProbability, t + 1);                h = currentDiscountedPayoff();                numSum += deltaSt * h;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        } // end else if        else {            C[t] = discountedMonteCarloPrice(t, nPath);            for (int n = 0; n < nPath; n++) {                double deltaSt, deltaCt;                underlying.timeStep(whichProbability, t);                deltaSt = S[t + 1] - S[t];                C[t + 1] = discountedMonteCarloPrice(t + 1, nPath);                deltaCt = C[t + 1] - C[t];                numSum += deltaSt * deltaCt;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        }    }    public double minimumVarianceDelta(int whichProbability, int t, int nPath, Trigger rebalance) {        underlying.simulationInit(t);         //sets pathCounter to zero        if (hasAnalyticPrice()) {            // compute as E_t(DeltaS(t)DeltaC(t))/E_t(DeltaS(t)^2)            C[t] = discountedAnalyticPrice(t);            double numSum = 0, denomSum = 0;            for (int n = 0; n < nPath; n++) {                double deltaSt, deltaCt;                //path computation to time s of next hedge trade                int s = underlying.pathSegment(whichProbability, t, rebalance);                deltaSt = S[s] - S[t];                C[s] = discountedAnalyticPrice(s);                deltaCt = C[s] - C[t];                numSum += deltaSt * deltaCt;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        } // end if        else if (whichProbability == RISK_NEUTRAL_PROBABILITY) {            // compute as E_t(DeltaS(t)h)/E_t(DeltaS(t)^2)            double numSum = 0, denomSum = 0;            for (int n = 0; n < nPath; n++) {                double deltaSt, h;                //path computation to time s of next hedge trade                int s = underlying.pathSegment(whichProbability, t, rebalance);                deltaSt = S[s] - S[t];                underlying.newPathBranch(whichProbability, s);                h = currentDiscountedPayoff();                numSum += deltaSt * h;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        } // end else if        else { // whichProbability==MARKET_PROBABILITY            // compute gain as E_t(DeltaS(t)DeltaC(t))/E_t(DeltaS(t)^2)            // where C[t], C[t+1] are computed using path branching            C[t] = discountedMonteCarloPrice(t, nPath);            double numSum = 0, denomSum = 0;            for (int n = 0; n < nPath; n++) {                double deltaSt, deltaCt;                //path computation to time s of next hedge trade                int s = underlying.pathSegment(whichProbability, t, rebalance);                deltaSt = S[s] - S[t];                C[s] = discountedMonteCarloPrice(s, nPath);                deltaCt = C[s] - C[t];                numSum += deltaSt * deltaCt;                denomSum += deltaSt * deltaSt;            } // end for n            return numSum / denomSum;        } // end else    } // end minimumVarianceDelta    public double monteCarloDelta(int t, int nPath) {        double sum = 0, mean;        double sigmaSqrtdt = underlying.get_sigmaSqrtdt(t);        double[] Z = underlying.get_Z();   //driving Brownian increments        underlying.simulationInit(t);     //sets pathCounter to zero        // E_t[Z(t)h]        for (int n = 0; n < nPath; n++) {            underlying.newPathBranch(RISK_NEUTRAL_PROBABILITY, t);            double h = currentDiscountedPayoff();            sum += Z[t] * h;        }        mean = sum / nPath;            // E_t[Z(t)h]        return mean / (S[t] * sigmaSqrtdt);    } //end monteCarloDelta    public double quotientDelta(int t, int nPath) {        double deltaSt, deltaCt;        // compute as E_t(DeltaC(t))/E_t(DeltaS(t)^2)        if (hasAnalyticPrice()) C[t] = discountedAnalyticPrice(t);        else C[t] = discountedMonteCarloPrice(t, nPath);        double numSum = 0, denomSum = 0;        for (int n = 0; n < nPath; n++) {            underlying.timeStep(Flag.MARKET_PROBABILITY, t);            deltaSt = S[t + 1] - S[t];            if (hasAnalyticPrice()) C[t + 1] = discountedAnalyticPrice(t + 1);            else C[t + 1] = discountedMonteCarloPrice(t + 1, nPath);            deltaCt = C[t + 1] - C[t];            numSum += deltaCt;            denomSum += deltaSt;        }        return numSum / denomSum;    } // end quotientDelta    public double quotientDelta(int t, int nPath, Trigger rebalance) {        double deltaSt, deltaCt;        // compute as E_t(DeltaC(t))/E_t(DeltaS(t)^2)        if (hasAnalyticPrice()) C[t] = discountedAnalyticPrice(t);        else C[t] = discountedMonteCarloPrice(t, nPath);        double numSum = 0, denomSum = 0;        for (int n = 0; n < nPath; n++) {            int s = underlying.pathSegment(MARKET_PROBABILITY, t, rebalance);            deltaSt = S[s] - S[t];            if (hasAnalyticPrice()) C[s] = discountedAnalyticPrice(s);            else C[s] = discountedMonteCarloPrice(s, nPath);            deltaCt = C[s] - C[t];            numSum += deltaCt;            denomSum += deltaSt;        }        return numSum / denomSum;    } // end quotientDelta    public double analyticMinimumVarianceDelta(int whichProbability, int t) {        // if the underlying is not a dividend free ConstantVolatilityAsset        // error message and abort        if (!underlyingIsDividendFreeCVA()) {            String message =                    "Option.analyticMinimumVarianceDelta:\n" +                            "method implemented only if the underlying is a dividend free " +                            "ConstantVolatilityAsset. Exiting.";          //log it        }        if (whichProbability == MARKET_PROBABILITY)            return                    analyticDelta(t) + alpha * analyticThetaDelta(t) + beta * analyticSGamma(t);        else // whichProbability==RISK_NEUTRAL_PROBABILITY            return                    analyticDelta(t) + analyticThetaDelta(t) * (1 - 1 / (1 + a)) * dt                            + (b - 1) * (b + 2) * analyticSGamma(t) / 3;    }    public double analyticQuotientDelta(int t) {        // if the underlying is not a dividend free ConstantVolatilityAsset        // error message and abort        if (!underlyingIsDividendFreeCVA()) {            String message =                    "Option.analyticMinimumVarianceDelta:\n" +                            "method implemented only if the underlying is a dividend free " +                            "ConstantVolatilityAsset. Exiting.";         //log it        }        return                analyticDelta(t) + phi * analyticThetaDelta(t) + psi * analyticSGamma(t);    }    public double currentDiscountedHedgeGain(int whichDelta, int whichProbability, int nBranch,             double fixed_trc, double prop_trc) {        double gain = 0;        for (int t = 0; t < T; t++) {            double w = 0;               //the weight used by the various hedges            switch (whichDelta) {                case MINIMUM_VARIANCE_DELTA:                    w = minimumVarianceDelta(whichProbability, t, nBranch);                    break;                case ANALYTIC_MINIMUM_VARIANCE_DELTA:                    w = analyticMinimumVarianceDelta(whichProbability, t);                    break;                case MONTE_CARLO_DELTA:                    w = monteCarloDelta(t, nBranch);                    break;                case ANALYTIC_DELTA:                    w = analyticDelta(t);                    break;                case QUOTIENT_DELTA:                    w = quotientDelta(t, nBranch);                    break;                case ANALYTIC_QUOTIENT_DELTA:                    w = analyticQuotientDelta(t);            }            underlying.timeStep(whichProbability, t);            double deltaS = S[t + 1] - S[t],                    dividend = q * S[t] * dt;  //dividend in [t,t+1], 1 share            gain += w * (deltaS + dividend - prop_trc) - fixed_trc;        } //for t=0,...,T-1        //loss from short position in call        double D = currentDiscountedPayoff() - C[0];        gain -= D;        return gain;    }    public RandomVariable discountedHedgeGain(final int whichDelta, final int whichProbability, final int nBranch,             final double fixed_trc, final double prop_trc) {        return new RandomVariable() {            public double getValue(int t) {                return currentDiscountedHedgeGain                        (whichDelta, whichProbability, nBranch, fixed_trc, prop_trc);            }        }; // end return new    }}                                                      